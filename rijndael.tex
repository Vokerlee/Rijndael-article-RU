\section{Введение}

    \textit{Rijndael} на данный момент является стандартом шифрования привительства США по
    результатам проведённого конкурса \textit{Advanced Encryption Standard}, огранизованного
    Национальным институтом стандартов и технологий США.

    Потребности принятия нового стандарта возникли из-за того, что предыдущий стандарт --
    \textit{Data Encryption Standard} -- имел ключ длиной всего в 56 бит, что позволяло взломать
    шифр простым перебором ключей.

    Алгоритм Rijndael стал настолько популярным, что даже производители процессоров Intel и AMD
    ввели аппаратную поддержку инструкций, ускоряющих работу Rijndael.

\section{Принцип работы}
\subsection{Краткое описание}

    Пусть имеется набор входных данных $I$ и ключ $K$, а $B$ -- количество 32-битных слов, из которых
    состоят ключ и входные данные, то есть $I = (i_1, \dots, i_{B}, \dots, i_{4B})$ и
    $K = (k_1, \dots, k_{V}, \dots, k_{4V})$.
    Возможные значения $B$: 4, 5, 6, 7 и 8. Возможные значения $V$: 4, 5, 6, 7 и 8.

    Rijndael сводится к следующей формальной процедуре: получить согласно некоторым правилам
    шифро-текст $C = (c_1, \dots, c_{B}, \dots, c_{4B})$.

    Введём понятие $S$ (state) -- текущее состояние алгоритма, которое в начале соответствует входным данным $I$,
    в процессе применения алгоритма соответствует некоторому промежуточному представлению,
    а после применения алгоритма -- шифро-тексту $C$. $S$ является матрицей размером $4$ x $B$.

    Алгоритм состоит из следующих процедур:
    \begin{enumerate}
        \item Исходные данные помещаются в текущее состояние $S$ по следующему правилу:
            \begin{equation}
                S =
                \begin{Vmatrix}
                    s_{11} & s_{12} & \dots & s_{1B} \\
                    \dots \\
                    s_{41} & s_{42} & \dots & s_{4B}
                \end{Vmatrix} =
                \begin{Vmatrix}
                    i_{1} & i_{2} & \dots & i_{B} \\
                    \dots \\
                    i_{3B + 1} & i_{3B + 2} & \dots & i_{4B}
                \end{Vmatrix}
            \end{equation}

        \item К состоянию $S$ применяется процедура трансформации -- раунд (round) --  $N_R - 1$ раз,
        где $N_R$ может принимать значения от 10 до 14 включительно в зависимости от длины ключа $K$
        (10 раз соответствует минимальной длине ключа 128 бит и т.д.). Полное описание раунда
        изложено в главе \ref{Round}.

        \item К состоянию $S$ применяется последний раунд $N_R$ -- он немного отличается от предыдущих
        (подробнее об этом позже, см главу \ref{RoundDescription}).

        \item Состояние $S$ благополучно копируется в шифро-текст $C$:
        \begin{equation}
            C:
            \begin{Vmatrix}
                c_{1} & c_{2} & \dots & c_{B} \\
                \dots \\
                c_{3B + 1} & c_{3B + 2} & \dots & c_{4B}
            \end{Vmatrix} =
            \begin{Vmatrix}
                s_{11} & s_{12} & \dots & s_{1B} \\
                \dots \\
                s_{41} & s_{42} & \dots & s_{4B}
            \end{Vmatrix}
        \end{equation}
    \end{enumerate}

\subsection{Описание процедуры трансформации round} \label{Round}

\subsubsection{Про раундовые ключи}
    Для каждого раунда генерируется собственный раундовый ключ $W_{r}$ размером $B$ 32-битных слов,
    где $r$ -- номер раунда.
    Вместе с исходным шифро-ключом $W_{0} = K$ имеем массив ключей размером $B \cdot (N_R + 1)$ 32-битных слов:
    $W = (W_{0}, \dots, W_{N_R})$.

    Процедура генерации раундовых ключей $W_{r}$ называется "Расширение ключа" \\
    (\textit{KeyExpansion, подробнее в главе \ref{KeyExpansion}}).

    \subsubsection{Описание процедуры} \label{RoundDescription}
    Процедура round при $0 \leq r < N_R$ над текущим состоянием $S$ состоит из следующих этапов:
    \begin{enumerate}
        \item Применение процедуры "Сложить $S$ с ключом раунда $W_{r}$"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
        \item Применение процедуры "Использовать нелинейную таблицу замен для $S$"\;(\textit{SubBytes, подробнее в главе \ref{SubBytes}}).
        \item Применение процедуры "Сдвинуть строки в $S$"\;(\textit{ShiftRows, подробнее в главе \ref{ShiftRows}}).
        \item Применение процедуры "Перемножить колонки $S$ с полиномом"\;(\textit{MixColumns, подробнее в главе \ref{MixColumns}}).
    \end{enumerate}

    Процедура round при $r = N_R$, как уже было сказано, слегка отличается от предыдущих:
    \begin{enumerate}
        \item Применение процедуры "Сложить $S$ с ключом раунда $W_{N_R}$"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
        \item Применение процедуры "Использовать нелинейную таблицу замен для $S$"\;(\textit{SubBytes, подробнее в главе \ref{SubBytes}}).
        \item Применение процедуры "Сдвинуть строки в $S$"\;(\textit{ShiftRows, подробнее в главе \ref{ShiftRows}}).
        \item Применение процедуры "Сложить $S$ с ключом раунда"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
    \end{enumerate}

\subsection{Описание вспомогательных процедур}

\subsubsection{Процедура \textit{AddRoundKey}} \label{AddRoundKey}

    Процедура может быть описана следующим образом: имеется текущее состояние $S$, описываемое в виде матрицы, и
    раундовый ключ $W_{r} = (w_1, \dots, w_{B}, \dots, w_{4B})$, новое состояние получается операцией
    \begin{equation}
        S :=
        \begin{Vmatrix}
            s_{11} \oplus w_1 & s_{12} \oplus w_2 & \dots & s_{1B} \oplus w_B \\
            \dots \\
            s_{41} \oplus w_{3B + 1} & s_{42} \oplus w_{3B + 2} & \dots & s_{4B} \oplus w_{4B}.
        \end{Vmatrix}
    \end{equation}

\subsubsection{Процедура \textit{SubBytes}} \label{SubBytes}

    Для процедуры $SubBytes$ требуется таблица замен S-box: именно благодаря этой операции обеспечивается
    нелинейность алгоритма шифрования. Рассмотрим подробнее алгоритм генерации таблицы замен S-box.

    Для начала определим $x^8 + x^4 + x^3 + x + 1$ -- неприводимый многочлен в поле Галуа $GF(2^8)$.
    В дальнейшем будем работать только в этом поле.

    S-box -- таблица размерами 16 x 16 байт, в которой изначально $ij$-ый байт имеет значение $16 \cdot (i - 1) + j - 1$.
    Каждый байт $b$ матрицы S-box заменяется обратным ему элементом $b^{-1}$.

    Далее, выберем произвольный байт $S\-box_{ij} = c$, который преобразуем следующим образом:
    \begin{equation}
        \begin{Vmatrix}
            c_1 \\
            c_2 \\
            c_3 \\
            c_4 \\
            c_5 \\
            c_6 \\
            c_7 \\
            c_8 \\
        \end{Vmatrix} :=
        \begin{Vmatrix}
            1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
            1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\
            1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\
            1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
            1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
            0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
            0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
            0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
        \end{Vmatrix} \cdot
        \begin{Vmatrix}
            c_1 \\
            c_2 \\
            c_3 \\
            c_4 \\
            c_5 \\
            c_6 \\
            c_7 \\
            c_8 \\
        \end{Vmatrix} +
        \begin{Vmatrix}
            1 \\
            1 \\
            0 \\
            0 \\
            0 \\
            1 \\
            1 \\
            0 \\
        \end{Vmatrix},
    \end{equation}

    где $c_{i}$ - $i$-ый бит байта $c$.

    Более коротким способом эту формулу можно записать как
    \begin{equation}
        c_{i} := c_{i} \oplus c_{(i + 4) \; mod \; 8} \oplus c_{(i + 5) \; mod \; 8} \oplus c_{(i + 6) \; mod \; 8}
        \oplus c_{(i + 7) \; mod \; 8} \oplus d_{i},
    \end{equation}

    где $d_{i}$ -- $i$-ый бит числа $63_{16} = 01100011_{2}$.

    Проделывая такие же шаги для всех остальный байтов $S\-box_{ij}$ матрицы S-box, получим готовую таблицу замен.

    Остаётся лишь ей воспользоваться: в матрицей текущего состояния $S$ берём байт
    $s_{ij}$ = $(\overline{x1 \; x2 \; x3 \; x4} \; \overline{y1 \; y2 \; y3 \; y4})$, где $x_{i}$, $y_{i}$ -- последовательные
    биты байта $s_{ij}$. Тогда пусть $\overline{x1 \; x2 \; x3 \; x4}_2 + 1$ -- номер строки в таблице замен,
    $\overline{y1 \; y2 \; y3 \; y4} + 1$ -- номер столбца в таблице замен, сопоставляем по этим номерам новое значение
    $s_{ij}$, полученное с помощью S-box.

\subsubsection{Процедура \textit{ShiftRows}} \label{ShiftRows}

    Процедура может быть описана следующим образом: имеется текущее состояние $S$, а новое состояние
    получается путем циклического сдвига влево строк матрицы $S$: $i$-ая строка сдвигается на $(i - 1)$
    байт.

    В матричмном виде это может быть записано как
    \begin{equation}
        S :=
        \begin{Vmatrix}
            s_{11} & s_{12} & \dots & s_{1(B - 1)} & s_{1B} \\
            s_{22} & s_{23} & \dots & s_{2B} & s_{21} \\
            s_{33} & s_{34} & \dots & s_{31} & s_{32} \\
            s_{44} & s_{45} & \dots & s_{42} & s_{43}
        \end{Vmatrix}
    \end{equation}

\subsubsection{Процедура \textit{MixColumns}} \label{MixColumns}

TBD

\subsubsection{Алгоритм генерации раундовых ключей \textit{KeyExpansion}} \label{KeyExpansion}

TBD
