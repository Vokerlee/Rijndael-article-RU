\section{Введение}

    \textit{Rijndael} на данный момент является стандартом шифрования привительства США по
    результатам проведённого конкурса \textit{Advanced Encryption Standard}, огранизованного
    Национальным институтом стандартов и технологий США.

    Потребности принятия нового стандарта возникли из-за того, что предыдущий стандарт --
    \textit{Data Encryption Standard} -- имел ключ длиной всего в 56 бит, что позволяло взломать
    шифр простым перебором ключей.

    Алгоритм Rijndael стал настолько популярным, что даже производители процессоров Intel и AMD
    ввели аппаратную поддержку инструкций, ускоряющих работу Rijndael.

\section{Принцип работы}
\subsection{Краткое описание алгоритма шифрования}

    Пусть имеется набор входных данных $I$ и ключ $K$, а $B$ -- количество 32-битных слов, из которых
    состоят ключ и входные данные, то есть $I = (i_1, \dots, i_{B}, \dots, i_{4B})$ и
    $K = (k_1, \dots, k_{V}, \dots, k_{4V})$.
    Возможные значения $B$: 4, 5, 6, 7 и 8. Возможные значения $V$: 4, 5, 6, 7 и 8.

    Rijndael сводится к следующей формальной процедуре: получить согласно некоторым правилам
    шифро-текст $C = (c_1, \dots, c_{B}, \dots, c_{4B})$.

    Введём понятие $S$ (state) -- текущее состояние алгоритма, которое в начале соответствует входным данным $I$,
    в процессе применения алгоритма соответствует некоторому промежуточному представлению,
    а после применения алгоритма -- шифро-тексту $C$. $S$ является матрицей размером $4 \cdot B$.

    Алгоритм состоит из следующих процедур:
    \begin{enumerate}
        \item Исходные данные помещаются в текущее состояние $S$ по следующему правилу:
            \begin{equation}
                S =
                \begin{Vmatrix}
                    s_{11} & s_{12} & \dots & s_{1B} \\
                    \dots \\
                    s_{41} & s_{42} & \dots & s_{4B}
                \end{Vmatrix} =
                \begin{Vmatrix}
                    i_{1} & i_{2} & \dots & i_{B} \\
                    \dots \\
                    i_{3B + 1} & i_{3B + 2} & \dots & i_{4B}
                \end{Vmatrix}
            \end{equation}

        \item К состоянию $S$ применяется процедура трансформации -- раунд (round) --  $N_R - 1$ раз,
        где $N_R$ может принимать значения от 10 до 14 включительно в зависимости от длины ключа $K$
        (10 раз соответствует минимальной длине ключа 128 бит и т.д.). Полное описание раунда
        изложено в главе \ref{Round}.

        \item К состоянию $S$ применяется последний раунд $N_R$ -- он немного отличается от предыдущих
        (подробнее об этом позже, см главу \ref{RoundDescription}).

        \item Состояние $S$ благополучно копируется в шифро-текст $C$:
        \begin{equation}
            C:
            \begin{Vmatrix}
                c_{1} & c_{2} & \dots & c_{B} \\
                \dots \\
                c_{3B + 1} & c_{3B + 2} & \dots & c_{4B}
            \end{Vmatrix} =
            \begin{Vmatrix}
                s_{11} & s_{12} & \dots & s_{1B} \\
                \dots \\
                s_{41} & s_{42} & \dots & s_{4B}
            \end{Vmatrix}
        \end{equation}
    \end{enumerate}

\subsection{Описание процедуры трансформации round} \label{Round}

\subsubsection{Про раундовые ключи}
    Для каждого раунда генерируется собственный раундовый ключ $W_{r}$, предствляющий собой матрицу такого же размера,
    что и матрица текущего состояния $S$, причём $r$ -- номер раунда.
    Имеется массив раундовых ключей размером $(N_R + 1)$: $W = (W_{0}, \dots, W_{N_R})$
    (будем считать нумерацию раундов с нуля).

    Процедура генерации раундовых ключей $W_{r}$ называется "Расширение ключа" \\
    (\textit{KeyExpansion, подробнее в главе \ref{KeyExpansion}}), в процедуре используется поданный на вход
    шифро-ключ $K$.

    \subsubsection{Описание процедуры} \label{RoundDescription}
    Процедура round при $0 \leq r < N_R$ над текущим состоянием $S$ состоит из следующих этапов:
    \begin{enumerate}
        \item Применение процедуры "Сложить $S$ с ключом раунда $W_{r}$"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
        \item Применение процедуры "Использовать нелинейную таблицу замен для $S$"\;(\textit{SubBytes, подробнее в главе \ref{SubBytes}}).
        \item Применение процедуры "Сдвинуть строки в $S$"\;(\textit{ShiftRows, подробнее в главе \ref{ShiftRows}}).
        \item Применение процедуры "Перемножить колонки $S$ с полиномом"\;(\textit{MixColumns, подробнее в главе \ref{MixColumns}}).
    \end{enumerate}

    Процедура round при $r = N_R$, как уже было сказано, слегка отличается от предыдущих:
    \begin{enumerate}
        \item Применение процедуры "Сложить $S$ с ключом раунда $W_{N_R}$"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
        \item Применение процедуры "Использовать нелинейную таблицу замен для $S$"\;(\textit{SubBytes, подробнее в главе \ref{SubBytes}}).
        \item Применение процедуры "Сдвинуть строки в $S$"\;(\textit{ShiftRows, подробнее в главе \ref{ShiftRows}}).
        \item Применение процедуры "Сложить $S$ с ключом раунда"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
    \end{enumerate}

\subsection{Описание вспомогательных процедур}

\subsubsection{Процедура \textit{AddRoundKey}} \label{AddRoundKey}

    Процедура может быть описана следующим образом: имеется текущее состояние $S$, описываемое в виде матрицы, и
    раундовый ключ $W_{r}$, представляющий собой матрицу такого же размера, что и $S$: новое состояние получается операцией
    \begin{equation}
        S :=
        \begin{Vmatrix}
            s_{11} \oplus w_{11} & s_{12} \oplus w_{12} & \dots & s_{1B} \oplus w_{1B} \\
            \dots \\
            s_{41} \oplus w_{41} & s_{42} \oplus w_{42} & \dots & s_{4B} \oplus w_{4B}.
        \end{Vmatrix}
    \end{equation}

\subsubsection{Процедура \textit{SubBytes}} \label{SubBytes}

    Для процедуры $SubBytes$ требуется таблица замен S-box: именно благодаря этой операции обеспечивается
    нелинейность алгоритма шифрования. Рассмотрим подробнее алгоритм генерации таблицы замен S-box.

    Для начала определим $x^8 + x^4 + x^3 + x + 1$ -- неприводимый многочлен в поле Галуа $GF(2^8)$.
    В дальнейшем будем работать только в этом поле.

    S-box -- таблица размерами $16 \cdot 16$ байт, в которой изначально $ij$-ый байт имеет значение $16 \cdot (i - 1) + j - 1$.
    Каждый байт $b$ матрицы S-box заменяется обратным ему элементом $b^{-1}$. Заметим, что элементом
    со значением 0 не имеет обратного -- присвоим ему значение $63_{16}$.

    Далее, выберем произвольный байт $S\-box_{ij} = c$, который преобразуем следующим образом:
    \begin{equation}
        \begin{Vmatrix}
            c_1 \\
            c_2 \\
            c_3 \\
            c_4 \\
            c_5 \\
            c_6 \\
            c_7 \\
            c_8 \\
        \end{Vmatrix} :=
        \begin{Vmatrix}
            1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
            1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\
            1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\
            1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
            1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
            0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
            0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
            0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
        \end{Vmatrix} \cdot
        \begin{Vmatrix}
            c_1 \\
            c_2 \\
            c_3 \\
            c_4 \\
            c_5 \\
            c_6 \\
            c_7 \\
            c_8 \\
        \end{Vmatrix} +
        \begin{Vmatrix}
            1 \\
            1 \\
            0 \\
            0 \\
            0 \\
            1 \\
            1 \\
            0 \\
        \end{Vmatrix},
    \end{equation}

    где $c_{i}$ - $i$-ый бит байта $c$.

    Более коротким способом эту формулу можно записать как
    \begin{equation}
        c_{i} := c_{i} \oplus c_{(i + 4) \; mod \; 8} \oplus c_{(i + 5) \; mod \; 8} \oplus c_{(i + 6) \; mod \; 8}
        \oplus c_{(i + 7) \; mod \; 8} \oplus d_{i},
    \end{equation}

    где $d_{i}$ -- $i$-ый бит числа $63_{16} = 01100011_{2}$.

    Проделывая такие же шаги для всех остальный байтов $S\-box_{ij}$ матрицы S-box, получим готовую таблицу замен.

    Остаётся лишь ей воспользоваться: в матрицей текущего состояния $S$ берём байт
    $s_{ij}$ = $(\overline{x1 \; x2 \; x3 \; x4} \; \overline{y1 \; y2 \; y3 \; y4})$, где $x_{i}$, $y_{i}$ -- последовательные
    биты байта $s_{ij}$. Тогда пусть $\overline{x1 \; x2 \; x3 \; x4}_2 + 1$ -- номер строки в таблице замен,
    $\overline{y1 \; y2 \; y3 \; y4} + 1$ -- номер столбца в таблице замен, сопоставляем по этим номерам новое значение
    $s_{ij}$, полученное с помощью S-box.

\subsubsection{Процедура \textit{ShiftRows}} \label{ShiftRows}

    Процедура может быть описана следующим образом: имеется текущее состояние $S$, а новое состояние
    получается путем циклического сдвига влево строк матрицы $S$: $i$-ая строка сдвигается на $(i - 1)$
    байт.

    В матричмном виде это может быть записано как
    \begin{equation}
        S :=
        \begin{Vmatrix}
            s_{11} & s_{12} & \dots & s_{1(B - 1)} & s_{1B} \\
            s_{22} & s_{23} & \dots & s_{2B} & s_{21} \\
            s_{33} & s_{34} & \dots & s_{31} & s_{32} \\
            s_{44} & s_{45} & \dots & s_{42} & s_{43}
        \end{Vmatrix}
    \end{equation}

    Однако у алгоритма Rijndael есть одна особенность: если $B = 8$, тогда смещения нужно делать не на
    $0, 1, 2$ и $3$ байта соответственно, а на $0, 1, 3$ и $4$ байта.

\subsubsection{Процедура \textit{MixColumns}} \label{MixColumns}

    Данная процедура считает каждый столбец матрицы состояния $S$ как коэффициенты полинома третьей степени в поле Галуа
    $GF(2^8)$. Каждый столбец умножается на полином $3x^3 + x^2 + x + 2$ по модулю $x^4 + 1$. Данная процедура нужна для того,
    чтобы внести дополнительную диффузию в текущее состояние $S$.

    Формально процедура может быть описана следующими формулами:

    \begin{equation}
        (s_{1j}' \cdot x^3 + s_{2j}' \cdot x^2 + s_{3j}' \cdot x^1 + s_{4j}') =
    \end{equation}
    \begin{equation}
        = \left( (s_{1j} \cdot x^3 + s_{2j} \cdot x^2 + s_{3j} \cdot x^1 + s_{4j}) \cdot (3x^3 + x^2 + x + 2) \right) (mod \; x^4 + 1),
    \end{equation}
    \begin{equation}
        s_{1j} := s_{1j}', \dots, s_{4j} := s_{4j}'.
    \end{equation}

\subsubsection{Алгоритм генерации раундовых ключей \textit{KeyExpansion}} \label{KeyExpansion}

    Рассмотрим подробнее генерацию раундовых ключей $W_r$, представляющих собой матрицы того же размера,
    что и матрица состояния $S$.

    С самого начала имеется шифро-ключ $K = (k_1, \dots, k_{V}, \dots, k_{4V})$, состоящий из $V$ 32-битных слов.
    Тогда алгоритм заполнения раундовых ключей выглядит следующим образом:
    \begin{enumerate}
        \item Для начала определим массив 32-битных слов $w[B \cdot (N_R + 1)]$. Пусть $i = 1$.
        \item Пока $i \leq V$, выполняем: $w[i] = (k_{i}, k_{i + 1}, k_{i + 2}, k_{i + 3})$, $i = i + 1$.
        \item Пока $i \leq B \cdot (N_R + 1)$, выполняем:
        \begin{enumerate}
            \item Пусть $a = w[i - 1]$.

            \begin{enumerate}
                \item Если $i = 0 \; (mod \; V)$, тогда $a = SubWord(RotWord(a)) \oplus Rcon[i / V]$.
                \item Иначе если $V > 6$ и $i = 4 \; (mod \; V)$, тогда $a = SubWord(a)$.
            \end{enumerate}

            \item Выполняем: $w[i] = w[i - V]$.
            \item Выполняем: $i = i + 1$.
        \end{enumerate}

        \item Копируем массив $w[B \cdot (N_R + 1)]$ в каждый раундовый ключ по следующему правилу: последовательно
        заполняем столбцы матриц $W_r$, по очереди перекладывая 32-битные слова $w[i]$, последовательно по каждому
        раундовому ключу $W_r$.
        \item В итоге имеем заполненные раундовые ключи $W_r$.
    \end{enumerate}

    В алгоритме применялись обозначения $SubWord(a)$, $RotWord(a)$ и $Rcon[i]$ -- объясним подробнее эти обозначения.

    Процедура $SubWord(a)$ является применением процедуры $SubBytes(a_{i})$ побайтово для 32-битного слова
    $a = (a_1, a_2, a_3, a_4)$.

    Процедура $RotWord(a)$ делает циклический сдвиг слево байтов в 32-битном слове $a$, например из $(a_1, a_2, a_3, a_4)$
    получаем $(a_2, a_3, a_4, a_1)$.

    $Rcon[i]$ -- массив слов, постоянный для текущего раунда, причём $Rcon[i] = (2^{i-1}, 0, 0, 0)$, $2^{i-1}$ считается
    в поле Галуа $GF(2^8)$. В алгоритме за $i / V$ обозначает целочисленное деление чисел с отбрасыванием отстатка.

\subsection{Краткое описание алгоритма дешифрования}

    Rijndael является симметричным алгоритмом блочного шифрования, что означает обратимость всех операций
    в алгоритме шифрования, разобранном выше. Действительно, операции $\oplus$, циклические сдвиги слов влево
    и прочие операции могут быть обращены.

    В частности, вводится инвертированная таблица нелинейных замен Inv-S-box,
    чтобы можно было восстановить данные на входе перед применением процедуры $SubBytes$.

    Процедура $MixColumns$ обращается за счёт домножения на другой многочлен в поле Галуа $GF(2^8)$.

    Во всём остальном алгоритм дешифрования повторяет алгоритм шифрования, однако по раундам требуется идти
    с конца в начало для корректного восстановления исходных данных.

    Если шифро-ключ неизвестен, то операцию $KeyExpansion$ провести не получится, а значит не будут известны
    раундовые ключи и расшифровать шифро-текст не получится.



