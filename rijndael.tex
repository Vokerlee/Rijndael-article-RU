\section{Введение}

    \textit{Rijndael} на данный момент является стандартом шифрования привительства США по
    результатам проведённого конкурса \textit{Advanced Encryption Standard}, огранизованного
    Национальным институтом стандартов и технологий США.

    Потребности принятия нового стандарта возникли из-за того, что предыдущий стандарт --
    \textit{Data Encryption Standard} -- имел ключ длиной всего в 56 бит, что позволяло взломать
    шифр простым перебором ключей.

    Алгоритм Rijndael стал настолько популярным, что даже производители процессоров Intel и AMD
    ввели аппаратную поддержку инструкций, ускоряющих работу Rijndael.

\section{Принцип работы}
\subsection{Краткое описание}

    Пусть имеется набор входных данных $I$ и ключ $K$, а $B$ -- количество 32-битных слов, из которых
    состоят ключ и входные данные, то есть $I = (i_1, \dots, i_{B}, \dots, i_{4B})$ и
    $K = (k_1, \dots, k_{V}, \dots, k_{4V})$.
    Возможные значения $B$: 4, 5, 6, 7 и 8. Возможные значения $V$: 4, 5, 6, 7 и 8.

    Rijndael сводится к следующей формальной процедуре: получить согласно некоторым правилам
    шифро-текст $C = (c_1, \dots, c_{B}, \dots, c_{4B})$.

    Введём понятие $S$ (state) -- текущее состояние алгоритма, которое в начале соответствует входным данным $I$,
    в процессе применения алгоритма соответствует некоторому промежуточному представлению,
    а после применения алгоритма -- шифро-тексту $C$. $S$ является матрицей размером $4$ x $B$.

    Алгоритм состоит из следующих процедур:
    \begin{enumerate}
        \item Исходные данные помещаются в текущее состояние $S$ по следующему правилу:
            \begin{equation}
                S =
                \begin{Vmatrix}
                    s_{11} & s_{12} & \dots & s_{1B} \\
                    \dots \\
                    s_{41} & s_{42} & \dots & s_{4B}
                \end{Vmatrix} =
                \begin{Vmatrix}
                    i_{1} & i_{2} & \dots & i_{B} \\
                    \dots \\
                    i_{3B + 1} & i_{3B + 2} & \dots & i_{4B}
                \end{Vmatrix}
            \end{equation}

        \item К состоянию $S$ применяется процедура трансформации -- раунд (round) --  $N_R - 1$ раз,
        где $N_R$ может принимать значения от 10 до 14 включительно в зависимости от длины ключа $K$
        (10 раз соответствует минимальной длине ключа 128 бит и т.д.). Полное описание раунда
        изложено в главе \ref{Round}.

        \item К состоянию $S$ применяется последний раунд $N_R$ -- он немного отличается от предыдущих
        (подробнее об этом позже, см главу \ref{RoundDescription}).

        \item Состояние $S$ благополучно копируется в шифро-текст $C$:
        \begin{equation}
            C:
            \begin{Vmatrix}
                c_{1} & c_{2} & \dots & c_{B} \\
                \dots \\
                c_{3B + 1} & c_{3B + 2} & \dots & c_{4B}
            \end{Vmatrix} =
            \begin{Vmatrix}
                s_{11} & s_{12} & \dots & s_{1B} \\
                \dots \\
                s_{41} & s_{42} & \dots & s_{4B}
            \end{Vmatrix}
        \end{equation}
    \end{enumerate}

\subsection{Описание процедуры трансформации round} \label{Round}

\subsubsection{Про раундовые ключи}
    Для каждого раунда генерируется собственный раундовый ключ $W_{r}$ размером $B$ 32-битных слов,
    где $r$ -- номер раунда.
    Вместе с исходным шифро-ключом $W_{0} = K$ имеем массив ключей размером $B \cdot (N_R + 1)$ 32-битных слов:
    $W = (W_{0}, \dots, W_{N_R})$.

    Процедура генерации раундовых ключей $W_{r}$ называется "Расширение ключа" \\
    (\textit{KeyExpansion, подробнее в главе \ref{KeyExpansion}}).

    \subsubsection{Описание процедуры} \label{RoundDescription}
    Процедура round при $0 \leq r < N_R$ над текущим состоянием $S$ состоит из следующих этапов:
    \begin{enumerate}
        \item Применение процедуры "Сложить $S$ с ключом раунда $W_{r}$"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
        \item Применение процедуры "Использовать нелинейную таблицу замен для $S$"\;(\textit{SubBytes, подробнее в главе \ref{SubBytes}}).
        \item Применение процедуры "Сдвинуть строки в $S$"\;(\textit{ShiftRows, подробнее в главе \ref{ShiftRows}}).
        \item Применение процедуры "Перемножить колонки $S$ с полиномом"\;(\textit{MixColumns, подробнее в главе \ref{MixColumns}}).
    \end{enumerate}

    Процедура round при $r = N_R$, как уже было сказано, слегка отличается от предыдущих:
    \begin{enumerate}
        \item Применение процедуры "Сложить $S$ с ключом раунда $W_{N_R}$"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
        \item Применение процедуры "Использовать нелинейную таблицу замен для $S$"\;(\textit{SubBytes, подробнее в главе \ref{SubBytes}}).
        \item Применение процедуры "Сдвинуть строки в $S$"\;(\textit{ShiftRows, подробнее в главе \ref{ShiftRows}}).
        \item Применение процедуры "Сложить $S$ с ключом раунда"\;(\textit{AddRoundKey, подробнее в главе \ref{AddRoundKey}}).
    \end{enumerate}

\subsection{Описание вспомогательных процедур}

\subsubsection{Процедура \textit{AddRoundKey}} \label{AddRoundKey}

TBD

\subsubsection{Процедура \textit{SubBytes}} \label{SubBytes}

TBD

\subsubsection{Процедура \textit{ShiftRows}} \label{ShiftRows}

TBD

\subsubsection{Процедура \textit{MixColumns}} \label{MixColumns}

TBD

\subsubsection{Алгоритм генерации раундовых ключей \textit{KeyExpansion}} \label{KeyExpansion}

TBD
